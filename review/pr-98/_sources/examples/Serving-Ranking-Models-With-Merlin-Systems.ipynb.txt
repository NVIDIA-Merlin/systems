{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "620dd990",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2022 NVIDIA Corporation. All Rights Reserved.\n",
    "#\n",
    "# Licensed under the Apache License, Version 2.0 (the \"License\");\n",
    "# you may not use this file except in compliance with the License.\n",
    "# You may obtain a copy of the License at\n",
    "#\n",
    "#     http://www.apache.org/licenses/LICENSE-2.0\n",
    "#\n",
    "# Unless required by applicable law or agreed to in writing, software\n",
    "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
    "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
    "# See the License for the specific language governing permissions and\n",
    "# limitations under the License.\n",
    "# =============================================================================="
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f550a0e5",
   "metadata": {},
   "source": [
    "<img src=\"http://developer.download.nvidia.com/compute/machine-learning/frameworks/nvidia_logo.png\" style=\"width: 90px; float: right;\">\n",
    "\n",
    "# Serving Ranking Models With Merlin Systems\n",
    "\n",
    "## Overview\n",
    "\n",
    "NVIDIA Merlin is an open source framework that accelerates and scales end-to-end recommender system pipelines. The Merlin framework is broken up into several sub components, these include: Merlin-Core, Merlin-Models, NVTabular and Merlin-Systems. Merlin Systems will be the focus of this example.\n",
    "\n",
    "The purpose of the Merlin Systems library is to make it easy for Merlin users to quickly deploy their recommender systems from development to [Triton Inference Server](https://github.com/triton-inference-server/server). We extended the same user-friendly API users are accustomed to in NVTabular and leveraged it to accommodate deploying your recommender system components to Triton. \n",
    "\n",
    "There are some things we need ensure before we continue with this Notebook. Please ensure you have a working workflow and model stored in an accessible location. As previously mentioned, Merlin Systems will take the data preprocessing workflow defined in NVTabular and load that into Triton as a model. Subsequently it will do the same for the trained model. Lets take a closer look in the rest of this notebook at how Merlin systems makes deploying to Triton simple and effortless.\n",
    "\n",
    "\n",
    "Be sure to check the other components of the Merlin framework, they can help you.\n",
    "\n",
    "### Learning objectives\n",
    "\n",
    "In this notebook, we learn how to deploy a NVTabular Workflow and a trained Tensorflow model from Merlin Models to Triton.\n",
    "- Load NVTabular Workflow\n",
    "- Load Pre-trained Merlin Models model\n",
    "- Create Ensemble Graph\n",
    "- Export Ensemble Graph\n",
    "- Run Tritonserver\n",
    "- Send Request to Tritonserver\n",
    "\n",
    "### Dataset\n",
    "\n",
    "In this notebook, we will be leveraging the [Alibaba dataset](https://tianchi.aliyun.com/dataset/dataDetail?dataId=408#1). It is important to note that the steps will take in this notebook are generalized and can be applied to any set of workflow and models. To see how the data is transformed please check the [NVTabular](https://github.com/NVIDIA-Merlin/NVTabular) example for the Alibaba dataset. And to see how an Alibaba dataset trained model is created check the [merlin-models](https://github.com/NVIDIA-Merlin/models)\n",
    "\n",
    "### Tools\n",
    "\n",
    "- NVTabular\n",
    "- Merlin Models\n",
    "- Merlin Systems\n",
    "- Triton Inference Server"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1346eec7-48d9-41b3-a3f7-c88230a6f24c",
   "metadata": {},
   "source": [
    "## Install Required Libraries\n",
    "\n",
    "Install TensorFlow so we can read the saved model from disk."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "3a0b7e5d-197b-42ec-9213-5582a85d140e",
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install tensorflow-gpu > /dev/null 2>&1 "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "222fde5f",
   "metadata": {},
   "source": [
    "## Load an NVTabular Workflow\n",
    "\n",
    "First, we load the `nvtabular.Workflow` that we created in with this [example](https://github.com/NVIDIA-Merlin/models/blob/main/examples/04-Exporting-ranking-models.ipynb). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "b1dc4a71",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "os.environ[\"TF_GPU_ALLOCATOR\"]=\"cuda_malloc_async\"\n",
    "from nvtabular.workflow import Workflow\n",
    "\n",
    "input_path = os.environ.get(\"INPUT_FOLDER\", \"/workspace/data/\")\n",
    "\n",
    "workflow_stored_path = os.path.join(input_path, \"workflow\")\n",
    "\n",
    "workflow = Workflow.load(workflow_stored_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "746fba56-36af-44a3-8beb-34ca026648be",
   "metadata": {},
   "source": [
    "After we load the workflow, we remove the label columns from it's inputs. This removes all columns with the `TARGET` tag from the workflow. We do this because we need to set the workflow to only  require the features needed to predict, not train, when creating an inference pipeline."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "bcef202e-fa6f-4c23-aca6-0b965faf637e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<nvtabular.workflow.workflow.Workflow at 0x7fc87e747130>"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from merlin.schema.tags import Tags\n",
    "\n",
    "label_columns = workflow.output_schema.select_by_tag(Tags.TARGET).column_names\n",
    "workflow.remove_inputs(label_columns)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "143795f2",
   "metadata": {},
   "source": [
    "## Load the Tensorflow Model\n",
    "\n",
    "After loading the workflow, we load the model. This model was trained with the output of the workflow from the [Exporting Ranking Models](https://github.com/NVIDIA-Merlin/models/blob/main/examples/04-Exporting-ranking-models.ipynb) example from Merlin Models."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "8da5e606",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-04-14 18:43:13.614628: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 FMA\n",
      "To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n",
      "2022-04-14 18:43:18.551263: I tensorflow/core/common_runtime/gpu/gpu_process_state.cc:214] Using CUDA malloc Async allocator for GPU: 0\n",
      "2022-04-14 18:43:18.551460: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1525] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 11562 MB memory:  -> device: 0, name: Tesla V100-DGXS-16GB, pci bus id: 0000:07:00.0, compute capability: 7.0\n",
      "2022-04-14 18:43:18.552259: I tensorflow/core/common_runtime/gpu/gpu_process_state.cc:214] Using CUDA malloc Async allocator for GPU: 1\n",
      "2022-04-14 18:43:18.552326: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1525] Created device /job:localhost/replica:0/task:0/device:GPU:1 with 12539 MB memory:  -> device: 1, name: Tesla V100-DGXS-16GB, pci bus id: 0000:08:00.0, compute capability: 7.0\n",
      "2022-04-14 18:43:18.553045: I tensorflow/core/common_runtime/gpu/gpu_process_state.cc:214] Using CUDA malloc Async allocator for GPU: 2\n",
      "2022-04-14 18:43:18.553106: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1525] Created device /job:localhost/replica:0/task:0/device:GPU:2 with 12719 MB memory:  -> device: 2, name: Tesla V100-DGXS-16GB, pci bus id: 0000:0e:00.0, compute capability: 7.0\n",
      "2022-04-14 18:43:18.553827: I tensorflow/core/common_runtime/gpu/gpu_process_state.cc:214] Using CUDA malloc Async allocator for GPU: 3\n",
      "2022-04-14 18:43:18.553886: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1525] Created device /job:localhost/replica:0/task:0/device:GPU:3 with 12719 MB memory:  -> device: 3, name: Tesla V100-DGXS-16GB, pci bus id: 0000:0f:00.0, compute capability: 7.0\n"
     ]
    }
   ],
   "source": [
    "import tensorflow as tf\n",
    "tf_model_path = os.path.join(input_path, \"dlrm\")\n",
    "\n",
    "model = tf.keras.models.load_model(tf_model_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "53908458",
   "metadata": {
    "tags": []
   },
   "source": [
    "## Create the Ensemble Graph\n",
    "\n",
    "After we have both the model and the workflow loaded, we can create the ensemble graph. You create the graph. The goal is to illustrate the path of data through your full system. In this example we only serve a workflow with a model, but you can add other components that help you meet your business logic requirements.\n",
    "\n",
    "Because this example has two components&mdash;a model and a workflow&mdash;we require two operators. These operators, also known as inference operators, are meant to abstract away all the \"hard parts\" of loading a specific component, such as a workflow or model, into Triton Inference Server. \n",
    "\n",
    "The following code block shows how to use two inference operators:\n",
    "\n",
    "<dl>\n",
    "    <dt><code>TransformWorkflow</code></dt>\n",
    "    <dd>This operator ensures that the workflow is correctly saved and packaged with the required config so the server will know how to load it.</dd>\n",
    "    <dt><code>PredictTensorflow</code></dt>\n",
    "    <dd>This operator will do something similar with the model, loaded before.</dd>\n",
    "</dl>\n",
    "\n",
    "Let's give it a try."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "f80e5cc8",
   "metadata": {},
   "outputs": [],
   "source": [
    "from merlin.systems.dag.ops.workflow import TransformWorkflow\n",
    "from merlin.systems.dag.ops.tensorflow import PredictTensorflow\n",
    "\n",
    "serving_operators = workflow.input_schema.column_names >> TransformWorkflow(workflow) >> PredictTensorflow(model)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8b916afa",
   "metadata": {},
   "source": [
    "## Export Graph as Ensemble\n",
    "\n",
    "The last step is to create the ensemble artifacts that Triton Inference Server can consume.\n",
    "To make these artifacts, we import the `Ensemble` class.\n",
    "The class is responsible for interpreting the graph and exporting the correct files for the server.\n",
    "\n",
    "After you run the following cell, you'll see that we create a `ColumnSchema` for the expected inputs to the workflow.\n",
    "The workflow is a `Schema`. \n",
    "\n",
    "When you are creating an `Ensemble` object you supply the graph and a schema representing the starting input of the graph. the inputs to the ensemble graph are the inputs to the first operator of your graph. \n",
    "\n",
    "After you have created the `Ensemble` you export the graph, supplying an export path for the `Ensemble.export` function.\n",
    "\n",
    "This returns an ensemble config which represents the entire inference pipeline and a list of node-specific configs.\n",
    "\n",
    "Let's take a look below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "2c9a7cd2-e14e-4b37-b0af-3dc3931c9ff9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[{'name': 'user_id', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'item_id', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'item_category', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'item_shop', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'item_brand', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_shops', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_profile', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_group', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_gender', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_age', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_consumption_2', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_is_occupied', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_geography', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_intentions', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_brands', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}, {'name': 'user_categories', 'tags': set(), 'properties': {}, 'dtype': dtype('int32'), 'is_list': False, 'is_ragged': False}]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "workflow.input_schema"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "c102204b",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-04-14 18:43:24.644857: W tensorflow/python/util/util.cc:368] Sets are not currently considered sequences, but this may change in the future, so consider avoiding using them.\n",
      "WARNING:absl:Found untraced functions such as restored_function_body, restored_function_body, restored_function_body, restored_function_body, click/binary_classification_task/output_layer_layer_call_fn while saving (showing 5 of 48). These functions will not be directly callable after loading.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INFO:tensorflow:Assets written to: /workspace/data/ensemble/1_predicttensorflow/1/model.savedmodel/assets\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:tensorflow:Assets written to: /workspace/data/ensemble/1_predicttensorflow/1/model.savedmodel/assets\n"
     ]
    }
   ],
   "source": [
    "from merlin.systems.dag.ensemble import Ensemble\n",
    "import numpy as np\n",
    "\n",
    "ensemble = Ensemble(serving_operators, workflow.input_schema)\n",
    "\n",
    "export_path = os.path.join(input_path, \"ensemble\")\n",
    "\n",
    "ens_conf, node_confs = ensemble.export(export_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4edcbd33-f845-4921-b295-46ad366da722",
   "metadata": {},
   "source": [
    "Display the path to the directory with the ensemble."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "64cc2ad6-78c7-47cf-b6bb-2de84a09f97e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/workspace/data/ensemble'"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "export_path"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "96aa55fb",
   "metadata": {},
   "source": [
    "## Verification of Ensemble Artifacts\n",
    "\n",
    "After we export the ensemble, we can check the export path for the graph's artifacts. The directory structure represents an ordering number followed by an operator identifier such as `1_transformworkflow`, `2_predicttensorflow`, and so on.\n",
    "\n",
    "Inside each of those directories, the `export` method writes a `config.pbtxt` file and a directory with a number. The number indicates the version and begins at 1. The artifacts for each operator are found inside the `version` folder. These artifacts vary depending on the operator in use. \n",
    "\n",
    "Install the `tree` executable so we can view some of the directory contents."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "ce10c04f-e3a4-4886-a5de-644dfe41c6e1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[01;34m/workspace/data/ensemble\u001b[00m\n",
      "├── \u001b[01;34m0_transformworkflow\u001b[00m\n",
      "│   ├── \u001b[01;34m1\u001b[00m\n",
      "│   └── config.pbtxt\n",
      "├── \u001b[01;34m1_predicttensorflow\u001b[00m\n",
      "│   ├── \u001b[01;34m1\u001b[00m\n",
      "│   └── config.pbtxt\n",
      "└── \u001b[01;34mensemble_model\u001b[00m\n",
      "    ├── \u001b[01;34m1\u001b[00m\n",
      "    └── config.pbtxt\n",
      "\n",
      "6 directories, 3 files\n"
     ]
    }
   ],
   "source": [
    "!apt update > /dev/null 2>&1\n",
    "!apt install tree > /dev/null 2>&1\n",
    "\n",
    "!tree -L 2 {export_path}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0b99146c",
   "metadata": {},
   "source": [
    "## Starting Triton Inference Server\n",
    "\n",
    "After we export the ensemble, we are ready to start the Triton Inference Server. The server is installed in all the Merlin inference containers.  If you are not using one of our containers, then ensure it is installed in your environment. For more information, see the Triton Inference Server [documentation](https://github.com/triton-inference-server/server/blob/r22.03/README.md#documentation). \n",
    "\n",
    "You can start the server by running the following command:\n",
    "\n",
    "```shell\n",
    "tritonserver --model-repository=/workspace/data/ensemble --backend-config=tensorflow,version=2\n",
    "```\n",
    "\n",
    "For the `--model-repository` argument, specify the same value as the `export_path` that you specified previously in the `ensemble.export` method.\n",
    "\n",
    "After you run the `tritonserver` command, wait until your terminal shows messages like the following example:\n",
    "\n",
    "```shell\n",
    "I0414 18:29:50.741833 4067 grpc_server.cc:4421] Started GRPCInferenceService at 0.0.0.0:8001\n",
    "I0414 18:29:50.742197 4067 http_server.cc:3113] Started HTTPService at 0.0.0.0:8000\n",
    "I0414 18:29:50.783470 4067 http_server.cc:178] Started Metrics Service at 0.0.0.0:8002\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c75e2eb9",
   "metadata": {},
   "source": [
    "## Retrieving Recommendations from Triton Inference Server\n",
    "\n",
    "Now that our server is running, we can send requests to it. This request is composed of values that correspond to the request schema that was created when we exported the ensemble graph.\n",
    "\n",
    "In the code below we create a request to send to triton and send it. We will then analyze the response, to show the full experience.\n",
    "\n",
    "First we need to ensure that we have a client connected to the server that we started. To do this, we use on the Triton HTTP client library."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "21a693ab-0ee3-443e-8ad4-fad030ec1985",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "client created.\n"
     ]
    }
   ],
   "source": [
    "import tritonclient.http as client\n",
    "\n",
    "# Create a triton client\n",
    "try:\n",
    "    triton_client = client.InferenceServerClient(url=\"localhost:8000\", verbose=True)\n",
    "    print(\"client created.\")\n",
    "except Exception as e:\n",
    "    print(\"channel creation failed: \" + str(e))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "358bb59b-796a-4e1e-8e02-b7d3b86c27f9",
   "metadata": {},
   "source": [
    "After we create the client and verified it is connected to the server instance, we can communicate with the server and ensure all the models are loaded correctly."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "ae48a6ee-d585-421b-bb5a-1a5c2edca058",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GET /v2/health/live, headers None\n",
      "<HTTPSocketPoolResponse status=200 headers={'content-length': '0', 'content-type': 'text/plain'}>\n",
      "POST /v2/repository/index, headers None\n",
      "\n",
      "<HTTPSocketPoolResponse status=200 headers={'content-type': 'application/json', 'content-length': '179'}>\n",
      "bytearray(b'[{\"name\":\"0_transformworkflow\",\"version\":\"1\",\"state\":\"READY\"},{\"name\":\"1_predicttensorflow\",\"version\":\"1\",\"state\":\"READY\"},{\"name\":\"ensemble_model\",\"version\":\"1\",\"state\":\"READY\"}]')\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[{'name': '0_transformworkflow', 'version': '1', 'state': 'READY'},\n",
       " {'name': '1_predicttensorflow', 'version': '1', 'state': 'READY'},\n",
       " {'name': 'ensemble_model', 'version': '1', 'state': 'READY'}]"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# ensure triton is in a good state\n",
    "triton_client.is_server_live()\n",
    "triton_client.get_model_repository_index()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dfbc6f01-5ccf-43a2-ae4f-8451a420fc70",
   "metadata": {},
   "source": [
    "After verifying the models are correctly loaded by the server, we use some original validation data and send it as an inference request to the server.\n",
    "\n",
    "> The `df_lib` object is `cudf` if a GPU is available and `pandas` otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "3235eb79-494a-4d92-b3d7-b74091c4e28b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>user_id</th>\n",
       "      <th>item_id</th>\n",
       "      <th>item_category</th>\n",
       "      <th>item_shop</th>\n",
       "      <th>item_brand</th>\n",
       "      <th>user_shops</th>\n",
       "      <th>user_profile</th>\n",
       "      <th>user_group</th>\n",
       "      <th>user_gender</th>\n",
       "      <th>user_age</th>\n",
       "      <th>user_consumption_2</th>\n",
       "      <th>user_is_occupied</th>\n",
       "      <th>user_geography</th>\n",
       "      <th>user_intentions</th>\n",
       "      <th>user_brands</th>\n",
       "      <th>user_categories</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>__null_dask_index__</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>700000</th>\n",
       "      <td>7</td>\n",
       "      <td>6</td>\n",
       "      <td>21</td>\n",
       "      <td>1447</td>\n",
       "      <td>499</td>\n",
       "      <td>272</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>79</td>\n",
       "      <td>135</td>\n",
       "      <td>15</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>700001</th>\n",
       "      <td>9</td>\n",
       "      <td>75</td>\n",
       "      <td>304</td>\n",
       "      <td>21404</td>\n",
       "      <td>7371</td>\n",
       "      <td>362</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>105</td>\n",
       "      <td>180</td>\n",
       "      <td>19</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>700002</th>\n",
       "      <td>14</td>\n",
       "      <td>10</td>\n",
       "      <td>37</td>\n",
       "      <td>2604</td>\n",
       "      <td>897</td>\n",
       "      <td>588</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>170</td>\n",
       "      <td>292</td>\n",
       "      <td>31</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                     user_id  item_id  item_category  item_shop  item_brand  \\\n",
       "__null_dask_index__                                                           \n",
       "700000                     7        6             21       1447         499   \n",
       "700001                     9       75            304      21404        7371   \n",
       "700002                    14       10             37       2604         897   \n",
       "\n",
       "                     user_shops  user_profile  user_group  user_gender  \\\n",
       "__null_dask_index__                                                      \n",
       "700000                      272             1           1            1   \n",
       "700001                      362             1           1            1   \n",
       "700002                      588             1           1            1   \n",
       "\n",
       "                     user_age  user_consumption_2  user_is_occupied  \\\n",
       "__null_dask_index__                                                   \n",
       "700000                      1                   1                 1   \n",
       "700001                      1                   1                 1   \n",
       "700002                      1                   1                 1   \n",
       "\n",
       "                     user_geography  user_intentions  user_brands  \\\n",
       "__null_dask_index__                                                 \n",
       "700000                            1               79          135   \n",
       "700001                            1              105          180   \n",
       "700002                            1              170          292   \n",
       "\n",
       "                     user_categories  \n",
       "__null_dask_index__                   \n",
       "700000                            15  \n",
       "700001                            19  \n",
       "700002                            31  "
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from merlin.core.dispatch import get_lib\n",
    "\n",
    "df_lib = get_lib()\n",
    "\n",
    "original_data_path = os.environ.get(\"INPUT_FOLDER\", \"/workspace/data/\")\n",
    "\n",
    "# read in data for request\n",
    "batch = df_lib.read_parquet(\n",
    "    os.path.join(original_data_path,\"valid\", \"part.0.parquet\"), num_rows=3, columns=workflow.input_schema.column_names\n",
    ")\n",
    "batch"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9691d28f-80d8-4520-b6e6-b7e260c50380",
   "metadata": {},
   "source": [
    "After we isolate our `batch`, we convert the dataframe representation into inputs for Triton. We also declare the outputs that we expect to receive from the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "fe53865c-9099-478c-8a30-17140ec1c120",
   "metadata": {},
   "outputs": [],
   "source": [
    "from merlin.systems.triton import convert_df_to_triton_input\n",
    "import tritonclient.grpc as grpcclient\n",
    "# create inputs and outputs\n",
    "\n",
    "inputs = convert_df_to_triton_input(workflow.input_schema.column_names, batch, grpcclient.InferInput)\n",
    "\n",
    "outputs = [\n",
    "    grpcclient.InferRequestedOutput(col)\n",
    "    for col in ensemble.graph.output_schema.column_names\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "50fb442d-d918-4b1a-a825-dfce4f75bc02",
   "metadata": {},
   "source": [
    "Now that our `inputs` and `outputs` are created, we can use the `triton_client` that we created earlier to send the inference request."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "1c9031d7-a242-4278-808f-26d307e6a0db",
   "metadata": {},
   "outputs": [],
   "source": [
    "# send request to tritonserver\n",
    "with grpcclient.InferenceServerClient(\"localhost:8001\") as client:\n",
    "    response = client.infer(\"ensemble_model\", inputs, request_id=\"1\", outputs=outputs)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10c00a98-a30e-45ca-9ab6-667621a20c75",
   "metadata": {},
   "source": [
    "When the server completes the inference request, it returns a response. This response is parsed to get the desired predictions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "4700c280-73e9-400a-ae9a-ee723789c96d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "output_1 [[0.50345296]\n",
      " [0.50178283]\n",
      " [0.5061866 ]] (3, 1)\n"
     ]
    }
   ],
   "source": [
    "# access individual response columns to get values back.\n",
    "for col in ensemble.graph.output_schema.column_names:\n",
    "    print(col, response.as_numpy(col), response.as_numpy(col).shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c06066f-5786-4f1b-b4f1-7e8a1e237183",
   "metadata": {},
   "source": [
    "## Summary\n",
    "\n",
    "This sample notebook started with an exported DLRM model and workflow.  We saw how to create an ensemble graph,\n",
    "verify the ensemble artifacts in the file system, and then put the ensemble into production with\n",
    "Triton Inference Server.  Finally, we sent a simple inference request to the server and printed the response."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
